<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>太空射击 - 网页版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        space: {
                            black: '#00000A',
                            blue: '#32C8FF',
                            red: '#FF5050',
                            orange: '#FF9632',
                            purple: '#B432FF',
                            yellow: '#FFFF00',
                            shield: '#6496FF',
                            health: '#32FF64',
                            speed: '#FFC832',
                            bullet: '#FFD700',
                            special: '#FF00FF'
                        }
                    },
                    fontFamily: {
                        game: ['Arial', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            }
            .glow {
                filter: drop-shadow(0 0 5px currentColor);
            }
            .pulse {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
            .virtual-btn {
                @apply fixed bg-white/20 backdrop-blur-md rounded-full flex items-center justify-center 
                       touch-manipulation active:bg-white/40 transition-all duration-150 z-30;
            }
            .d-pad {
                @apply fixed left-4 bottom-4 z-30 grid grid-cols-3 grid-rows-3 gap-1 w-32 h-32;
            }
            .d-pad-btn {
                @apply bg-white/20 backdrop-blur-md rounded-md flex items-center justify-center 
                       touch-manipulation active:bg-white/40 transition-all duration-150;
            }
        }
    </style>
</head>
<body class="bg-space-black overflow-hidden m-0 p-0 font-game text-white">
    <div id="game-container" class="relative w-full h-screen flex flex-col items-center justify-center">
        <!-- 星空背景 -->
        <div id="stars" class="absolute inset-0 z-0"></div>
        
        <!-- 游戏画布 -->
        <canvas id="game-canvas" class="z-10 border-2 border-white/20 rounded-md shadow-lg"></canvas>
        
        <!-- 游戏信息 -->
        <div id="game-info" class="absolute top-4 left-4 z-20 bg-space-black/60 backdrop-blur-sm p-3 rounded-lg border border-white/20">
            <div class="flex items-center mb-2">
                <i class="fa fa-star text-yellow-400 mr-2"></i>
                <span id="score">分数: 0</span>
            </div>
            <div class="flex items-center mb-2">
                <i class="fa fa-signal text-space-blue mr-2"></i>
                <span id="level">等级: 1</span>
            </div>
            <div class="flex items-center">
                <i class="fa fa-bolt text-space-orange mr-2"></i>
                <span id="special">技能: <span id="special-charge">0</span>/<span id="special-max">100</span></span>
            </div>
        </div>
        
        <!-- 玩家状态 -->
        <div id="player-status" class="absolute bottom-4 left-4 z-20 bg-space-black/60 backdrop-blur-sm p-3 rounded-lg border border-white/20">
            <div class="flex items-center mb-2">
                <div class="w-32 bg-gray-700 rounded-full h-2.5 mr-2">
                    <div id="health-bar" class="bg-space-health h-2.5 rounded-full" style="width: 100%"></div>
                </div>
                <span id="health-text">100</span>
            </div>
            <div class="flex items-center">
                <div class="w-32 bg-gray-700 rounded-full h-2.5 mr-2">
                    <div id="shield-bar" class="bg-space-shield h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <span id="shield-text">0</span>
            </div>
        </div>
        
        <!-- 控制提示 (仅桌面显示) -->
        <div id="desktop-controls" class="absolute bottom-4 right-4 z-20 bg-space-black/60 backdrop-blur-sm p-3 rounded-lg border border-white/20 text-sm hidden md:block">
            <div class="flex items-center mb-2">
                <span class="px-2 py-1 bg-gray-700 rounded mr-2">← → ↑ ↓</span>
                <span>移动</span>
            </div>
            <div class="flex items-center mb-2">
                <span class="px-2 py-1 bg-gray-700 rounded mr-2">空格</span>
                <span>射击</span>
            </div>
            <div class="flex items-center">
                <span class="px-2 py-1 bg-space-orange rounded mr-2">X</span>
                <span>使用技能</span>
            </div>
        </div>
        
        <!-- 手机端虚拟按键 -->
        <div class="d-pad md:hidden">
            <div class="col-start-2 row-start-1 d-pad-btn" data-key="ArrowUp">
                <i class="fa fa-arrow-up"></i>
            </div>
            <div class="col-start-1 row-start-2 d-pad-btn" data-key="ArrowLeft">
                <i class="fa fa-arrow-left"></i>
            </div>
            <div class="col-start-2 row-start-2 d-pad-btn" data-key="Space" style="opacity: 0.5;">
                <i class="fa fa-circle-o"></i>
            </div>
            <div class="col-start-3 row-start-2 d-pad-btn" data-key="ArrowRight">
                <i class="fa fa-arrow-right"></i>
            </div>
            <div class="col-start-2 row-start-3 d-pad-btn" data-key="ArrowDown">
                <i class="fa fa-arrow-down"></i>
            </div>
        </div>
        
        <!-- 手机端射击按钮 -->
        <div class="virtual-btn md:hidden" style="width: 60px; height: 60px; right: 40px; bottom: 40px;" data-key="Space">
            <i class="fa fa-crosshairs text-2xl"></i>
        </div>
        
        <!-- 手机端技能按钮 -->
        <div class="virtual-btn md:hidden" style="width: 50px; height: 50px; right: 40px; bottom: 110px; background-color: rgba(255, 150, 50, 0.3);" data-key="KeyX">
            <i class="fa fa-bolt text-xl"></i>
        </div>
        
        <!-- 开始菜单 -->
        <div id="start-menu" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-space-black/80 backdrop-blur-sm">
            <h1 class="text-[clamp(2.5rem,8vw,5rem)] font-bold text-space-blue mb-10 text-shadow">星际射手</h1>
            <div class="space-y-4 text-xl text-center max-w-md px-4">
                <div class="flex items-center justify-center">
                    <i class="fa fa-arrow-left text-space-blue mr-2"></i>
                    <i class="fa fa-arrow-right text-space-blue mx-2"></i>
                    <i class="fa fa-arrow-up text-space-blue mx-2"></i>
                    <i class="fa fa-arrow-down text-space-blue ml-2"></i>
                    <span class="ml-4">移动飞船</span>
                </div>
                <div class="flex items-center justify-center">
                    <i class="fa fa-space-shuttle text-space-yellow mr-2"></i>
                    <span>空格键 发射激光</span>
                </div>
                <div class="flex items-center justify-center">
                    <i class="fa fa-bolt text-space-orange mr-2"></i>
                    <span>X键 使用特殊技能</span>
                </div>
                <p class="text-sm text-gray-300 mt-4 md:hidden">
                    手机用户：使用屏幕虚拟按键操作
                </p>
                <button id="start-button" class="mt-8 px-8 py-3 bg-space-blue hover:bg-space-blue/80 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                    开始游戏
                </button>
            </div>
        </div>
        
        <!-- 游戏结束菜单 -->
        <div id="game-over" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-space-black/80 backdrop-blur-sm hidden">
            <h1 class="text-[clamp(2.5rem,8vw,5rem)] font-bold text-space-red mb-6 text-shadow">游戏结束</h1>
            <p class="text-2xl mb-2">最终得分: <span id="final-score">0</span></p>
            <p class="text-xl mb-8">等级: <span id="final-level">1</span></p>
            <button id="restart-button" class="px-8 py-3 bg-space-blue hover:bg-space-blue/80 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                重新开始
            </button>
        </div>
        
        <!-- 暂停菜单 -->
        <div id="pause-menu" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-space-black/80 backdrop-blur-sm hidden">
            <h1 class="text-[clamp(2.5rem,8vw,5rem)] font-bold text-space-blue mb-10 text-shadow">游戏暂停</h1>
            <button id="resume-button" class="mt-4 px-8 py-3 bg-space-blue hover:bg-space-blue/80 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                继续游戏
            </button>
            <button id="restart-button-pause" class="mt-4 px-8 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                重新开始
            </button>
        </div>
    </div>

    <script>
        // 游戏常量
        const WIDTH = 800;
        const HEIGHT = 600;
        const PLAYER_SPEED = 6.5;
        const BULLET_SPEED = 10;
        const ENEMY_SPEED_FACTOR = 0.8; // 敌机速度降低20%
        
        // 敌机类型定义
        const ENEMY_TYPES = [
            { 
                width: 40, 
                height: 36, 
                color: 'space-red', 
                health: 1, 
                points: 10, 
                speed: 2 * ENEMY_SPEED_FACTOR,
                sprite: [
                    [0,0,1,1,0,0],
                    [0,1,1,1,1,0],
                    [1,1,1,1,1,1],
                    [1,1,0,0,1,1],
                    [0,1,0,0,1,0],
                    [0,0,1,1,0,0]
                ]
            },
            { 
                width: 32, 
                height: 28, 
                color: 'space-orange', 
                health: 1, 
                points: 15, 
                speed: 3.5 * ENEMY_SPEED_FACTOR,
                sprite: [
                    [0,1,1,1,1,0],
                    [1,1,1,1,1,1],
                    [1,1,0,0,1,1],
                    [0,1,1,1,1,0],
                    [0,0,1,1,0,0]
                ]
            },
            { 
                width: 56, 
                height: 48, 
                color: 'space-purple', 
                health: 3, 
                points: 25, 
                speed: 1.5 * ENEMY_SPEED_FACTOR,
                sprite: [
                    [0,0,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1],
                    [1,1,0,1,1,0,1,1],
                    [1,1,0,1,1,0,1,1],
                    [1,1,1,1,1,1,1,1],
                    [0,1,1,0,0,1,1,0],
                    [0,0,1,1,1,1,0,0]
                ]
            },
            { 
                width: 72, 
                height: 64, 
                color: 'space-blue', 
                health: 10, 
                points: 100, 
                speed: 1 * ENEMY_SPEED_FACTOR,
                sprite: [
                    [0,0,0,1,1,1,1,0,0,0],
                    [0,0,1,1,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,1,1,0],
                    [1,1,1,0,1,1,0,1,1,1],
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,1,1,1,0,0,1,1,1,1],
                    [1,1,0,0,0,0,0,0,1,1],
                    [0,1,0,0,0,0,0,0,1,0],
                    [0,0,1,1,0,0,1,1,0,0],
                    [0,0,0,1,1,1,1,0,0,0]
                ]
            }
        ];
        
        // 道具类型与生成类型
        const POWERUP_TYPES = {
            HEALTH: { color: 'space-health', text: 'H' },
            SHIELD: { color: 'space-shield', text: 'S' },
            SPEED: { color: 'space-speed', text: 'F' },
            BULLET_UPGRADE: { color: 'space-yellow', text: 'B' },
            SPECIAL_CHARGE: { color: 'space-orange', text: 'P' }
        };
        
        const POWERUP_SPAWN_TYPE = {
            DROPPED: 'dropped',
            RANDOM: 'random'
        };
        
        // 子弹类型
        const BULLET_TYPES = {
            NORMAL: { width: 6, height: 20, color: 'space-yellow', damage: 1 },
            UPGRADED: { width: 8, height: 24, color: 'space-blue', damage: 2 },
            SPECIAL: { width: 12, height: 30, color: 'space-special', damage: 5 },
            SPREAD: { width: 7, height: 22, color: 'space-purple', damage: 1.5 }
        };
        
        // 游戏变量
        let canvas, ctx;
        let player, bullets, enemies, explosions, powerups, planets, asteroids;
        let score, level, gameOver, lastEnemySpawn, enemySpawnRate, gamePaused;
        let keys = {};
        let stars = [];
        let animationId;
        let bulletType = BULLET_TYPES.NORMAL;
        let specialCharge = 0;
        let specialMaxCharge = 100;
        let lastSpecialUsed = 0;
        let specialCooldown = 5000; // 5秒冷却
        let lastRandomPowerupTime = 0;
        
        // 平滑移动变量
        let moveVelocityX = 0;
        let moveVelocityY = 0;
        const MOVE_ACCELERATION = 0.5;
        const MOVE_FRICTION = 0.8;
        
        // 手机触摸控制变量
        let touchButtons = {};
        let isTouchShooting = false;
        
        // 初始化游戏
        function init() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            
            // 适配手机屏幕缩放
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化游戏状态
            score = 0;
            level = 1;
            gameOver = false;
            gamePaused = false;
            lastEnemySpawn = 0;
            enemySpawnRate = 1500;
            specialCharge = 0;
            
            // 创建玩家
            player = {
                x: WIDTH / 2 - 30,
                y: HEIGHT - 80,
                width: 60,
                height: 50,
                speed: PLAYER_SPEED,
                health: 100,
                shield: 0,
                shootDelay: 180, // 缩短射击间隔
                lastShot: 0,
                speedBoost: 0,
                bulletUpgrade: 0,
                bulletSpread: 1,
                sprite: [
                    [0,0,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,0,0,1,1,1],
                    [1,1,0,0,0,0,1,1],
                    [1,0,0,0,0,0,0,1],
                    [0,0,1,0,0,1,0,0],
                    [0,0,1,0,0,1,0,0],
                    [0,0,0,1,1,0,0,0]
                ]
            };
            
            // 初始化数组
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            planets = [];
            asteroids = [];
            
            // 创建背景元素
            createStars();
            createPlanets();
            createAsteroids();
            
            // 绑定事件
            bindEvents();
            
            // 开始游戏循环
            gameLoop();
        }
        
        // 适配手机屏幕
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const containerRect = container.getBoundingClientRect();
            
            // 保持游戏画布比例
            const scale = Math.min(
                containerRect.width / WIDTH,
                containerRect.height / HEIGHT
            );
            
            canvas.style.transform = `scale(${scale})`;
            canvas.style.transformOrigin = 'center';
        }
        
        // 绑定事件处理（包括手机触摸）
        function bindEvents() {
            // 键盘事件
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Escape') togglePause();
                if (e.code === 'KeyX' && specialCharge >= specialMaxCharge && !gameOver && !gamePaused) {
                    useSpecial();
                }
            });
            window.addEventListener('keyup', (e) => keys[e.code] = false);
            
            // 虚拟按钮触摸事件
            document.querySelectorAll('.d-pad-btn, .virtual-btn').forEach(btn => {
                const key = btn.dataset.key;
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // 防止触摸滚动
                    keys[key] = true;
                    
                    // 射击按钮特殊处理
                    if (key === 'Space') {
                        isTouchShooting = true;
                        touchShootLoop();
                    }
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[key] = false;
                    
                    if (key === 'Space') {
                        isTouchShooting = false;
                    }
                });
                
                // 鼠标点击支持（用于测试）
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    keys[key] = true;
                    
                    if (key === 'Space') {
                        isTouchShooting = true;
                        touchShootLoop();
                    }
                });
                
                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    keys[key] = false;
                    
                    if (key === 'Space') {
                        isTouchShooting = false;
                    }
                });
                
                // 防止鼠标离开按钮区域
                btn.addEventListener('mouseleave', (e) => {
                    if (key === 'Space') {
                        keys[key] = false;
                        isTouchShooting = false;
                    }
                });
            });
            
            // 按钮事件
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            document.getElementById('restart-button-pause').addEventListener('click', restartGame);
            document.getElementById('resume-button').addEventListener('click', togglePause);
        }
        
        // 手机射击循环
        function touchShootLoop() {
            if (!isTouchShooting || gameOver || gamePaused) return;
            
            const now = Date.now();
            if (now - player.lastShot > player.shootDelay) {
                player.lastShot = now;
                shootBullet();
            }
            
            requestAnimationFrame(touchShootLoop);
        }
        
        // 射击函数（复用）
        function shootBullet() {
            if (player.bulletSpread === 1) {
                bullets.push({
                    x: player.x + player.width / 2 - bulletType.width / 2,
                    y: player.y - bulletType.height
                });
            } else if (player.bulletSpread === 3) {
                bullets.push({x: player.x + player.width / 2 - bulletType.width / 2, y: player.y - bulletType.height});
                bullets.push({x: player.x + player.width / 2 - bulletType.width / 2 - 15, y: player.y - bulletType.height, angle: -0.2});
                bullets.push({x: player.x + player.width / 2 - bulletType.width / 2 + 15, y: player.y - bulletType.height, angle: 0.2});
            }
            
            // 射击特效
            createExplosion(
                player.x + player.width / 2, 
                player.y - 10, 
                10, 
                false
            );
        }
        
        // 创建星空背景
        function createStars() {
            stars = [];
            for (let i = 0; i < 300; i++) {
                stars.push({
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    radius: Math.random() * 1.5,
                    speed: Math.random() * 0.5 + 0.1,
                    color: `rgba(${Math.random() * 200 + 55}, ${Math.random() * 200 + 55}, ${Math.random() * 255}, ${Math.random() * 0.7 + 0.3})`
                });
            }
            // 大星星点缀
            for (let i = 0; i < 20; i++) {
                stars.push({
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    radius: Math.random() * 2 + 1.5,
                    speed: Math.random() * 0.2 + 0.05,
                    color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 0.5 + 0.5})`,
                    blink: Math.random() > 0.5,
                    blinkPhase: Math.random() * Math.PI * 2
                });
            }
        }
        
        // 创建行星
        function createPlanets() {
            planets = [
                {x: WIDTH * 0.2, y: HEIGHT * 0.3, radius: 30, color: '#FFD740', speed: 0.02, hasRing: false},
                {x: WIDTH * 0.7, y: HEIGHT * 0.2, radius: 20, color: '#4FC3F7', speed: 0.015, hasRing: true},
                {x: WIDTH * 0.85, y: HEIGHT * 0.6, radius: 25, color: '#B39DDB', speed: 0.01, hasRing: false},
                {x: WIDTH * 0.1, y: HEIGHT * 0.8, radius: 15, color: '#EF9A9A', speed: 0.025, hasRing: false}
            ];
        }
        
        // 创建小行星带
        function createAsteroids() {
            asteroids = [];
            for (let i = 0; i < 50; i++) {
                asteroids.push({
                    x: WIDTH * 0.6 + Math.random() * WIDTH * 0.3,
                    y: HEIGHT * 0.3 + Math.random() * HEIGHT * 0.4,
                    radius: Math.random() * 3 + 1,
                    speed: (Math.random() - 0.5) * 0.2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    color: `rgba(${80 + Math.random() * 40}, ${80 + Math.random() * 40}, ${100 + Math.random() * 50}, 0.7)`
                });
            }
        }
        
        // 绘制星空背景
        function drawStars() {
            ctx.fillStyle = '#0A0A1A';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // 绘制星云
            drawNebula();
            
            // 绘制小行星带
            asteroids.forEach(asteroid => {
                asteroid.x = (asteroid.x + asteroid.speed) % (WIDTH + 100) - 50;
                asteroid.rotation += asteroid.rotationSpeed;
                
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);
                ctx.fillStyle = asteroid.color;
                ctx.beginPath();
                ctx.moveTo(0, -asteroid.radius);
                ctx.lineTo(asteroid.radius * 0.8, -asteroid.radius * 0.3);
                ctx.lineTo(asteroid.radius * 0.5, asteroid.radius * 0.7);
                ctx.lineTo(-asteroid.radius * 0.6, asteroid.radius * 0.5);
                ctx.lineTo(-asteroid.radius * 0.7, -asteroid.radius * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });
            
            // 绘制行星
            planets.forEach(planet => {
                planet.x = (planet.x + planet.speed) % (WIDTH + 100) - 50;
                
                const gradient = ctx.createRadialGradient(
                    planet.x - planet.radius * 0.2, 
                    planet.y - planet.radius * 0.2, 
                    0,
                    planet.x, 
                    planet.y, 
                    planet.radius
                );
                gradient.addColorStop(0, `${planet.color}FF`);
                gradient.addColorStop(0.7, `${planet.color}CC`);
                gradient.addColorStop(1, `${planet.color}40`);
                ctx.beginPath();
                ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // 行星表面纹理
                if (planet.radius > 20) {
                    ctx.fillStyle = `${planet.color}30`;
                    for (let i = 0; i < 5; i++) {
                        const spotRadius = Math.random() * planet.radius * 0.2 + 2;
                        ctx.beginPath();
                        ctx.arc(
                            planet.x + (Math.random() - 0.5) * planet.radius * 0.8,
                            planet.y + (Math.random() - 0.5) * planet.radius * 0.8,
                            spotRadius, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                // 行星光环
                if (planet.hasRing) {
                    ctx.strokeStyle = `${planet.color}20`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(planet.x, planet.y, planet.radius * 1.8, planet.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = `${planet.color}30`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(planet.x, planet.y, planet.radius * 1.5, planet.radius * 0.5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // 绘制星星
            stars.forEach(star => {
                star.y = (star.y + star.speed) % HEIGHT;
                if (star.blink) {
                    star.blinkPhase += 0.05;
                    const alpha = 0.4 + Math.sin(star.blinkPhase) * 0.6;
                    const colorParts = star.color.match(/\d+/g);
                    star.currentColor = `rgba(${colorParts[0]}, ${colorParts[1]}, ${colorParts[2]}, ${alpha})`;
                }
                
                if (star.radius > 1.5) {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = star.blink ? `${star.currentColor}20` : `${star.color}20`;
                    ctx.fill();
                }
                
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.blink ? star.currentColor : star.color;
                ctx.fill();
            });
        }
        
        // 绘制星云
        function drawNebula() {
            const gradient1 = ctx.createRadialGradient(
                WIDTH * 0.3, HEIGHT * 0.2, 50,
                WIDTH * 0.3, HEIGHT * 0.2, 300
            );
            gradient1.addColorStop(0, 'rgba(100, 100, 200, 0.05)');
            gradient1.addColorStop(1, 'rgba(100, 100, 200, 0)');
            
            const gradient2 = ctx.createRadialGradient(
                WIDTH * 0.7, HEIGHT * 0.7, 70,
                WIDTH * 0.7, HEIGHT * 0.7, 350
            );
            gradient2.addColorStop(0, 'rgba(120, 80, 180, 0.07)');
            gradient2.addColorStop(1, 'rgba(120, 80, 180, 0)');
            
            const gradient3 = ctx.createRadialGradient(
                WIDTH * 0.5, HEIGHT * 0.5, 100,
                WIDTH * 0.5, HEIGHT * 0.5, 400
            );
            gradient3.addColorStop(0, 'rgba(50, 50, 120, 0.05)');
            gradient3.addColorStop(1, 'rgba(50, 50, 120, 0)');
            
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = gradient2;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = gradient3;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }
        
        // 开始游戏
        function startGame() {
            document.getElementById('start-menu').classList.add('hidden');
            gameOver = false;
            score = 0;
            level = 1;
            player.health = 100;
            player.shield = 0;
            bulletType = BULLET_TYPES.NORMAL;
            player.bulletSpread = 1;
            specialCharge = 0;
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            updateGameInfo();
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 重新开始游戏
        function restartGame() {
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('pause-menu').classList.add('hidden');
            
            gameOver = false;
            gamePaused = false;
            score = 0;
            level = 1;
            player.health = 100;
            player.shield = 0;
            player.x = WIDTH / 2 - 30;
            player.y = HEIGHT - 80;
            bulletType = BULLET_TYPES.NORMAL;
            player.bulletSpread = 1;
            specialCharge = 0;
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            lastEnemySpawn = 0;
            lastRandomPowerupTime = 0;
            moveVelocityX = 0;
            moveVelocityY = 0;
            
            updateGameInfo();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 暂停/继续游戏
        function togglePause() {
            if (gameOver) return;
            gamePaused = !gamePaused;
            if (gamePaused) {
                document.getElementById('pause-menu').classList.remove('hidden');
                cancelAnimationFrame(animationId);
            } else {
                document.getElementById('pause-menu').classList.add('hidden');
                animationId = requestAnimationFrame(gameLoop);
            }
        }
        
        // 游戏结束
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('final-level').textContent = level;
            document.getElementById('game-over').classList.remove('hidden');
            cancelAnimationFrame(animationId);
        }
        
        // 更新游戏信息
        function updateGameInfo() {
            document.getElementById('score').textContent = `分数: ${score}`;
            document.getElementById('level').textContent = `等级: ${level}`;
            document.getElementById('special-charge').textContent = Math.floor(specialCharge);
            document.getElementById('health-text').textContent = Math.floor(player.health);
            document.getElementById('shield-text').textContent = Math.floor(player.shield);
            document.getElementById('health-bar').style.width = `${player.health}%`;
            document.getElementById('shield-bar').style.width = `${player.shield / 50 * 100}%`;
        }
        
        // 生成敌人
        function spawnEnemy(timestamp) {
            if (gameOver || gamePaused) return;
            if (timestamp - lastEnemySpawn > enemySpawnRate) {
                lastEnemySpawn = timestamp;
                level = 1 + Math.floor(score / 600);
                enemySpawnRate = Math.max(500, 1500 - (level - 1) * 100);
                const isBoss = Math.random() < 0.1 && level >= 3;
                const enemyType = isBoss ? 3 : Math.random() < 0.7 ? 0 : Math.random() < 0.9 ? 1 : 2;
                const enemy = {
                    ...ENEMY_TYPES[enemyType],
                    x: Math.random() * (WIDTH - ENEMY_TYPES[enemyType].width),
                    y: -ENEMY_TYPES[enemyType].height,
                    health: ENEMY_TYPES[enemyType].health * (1 + (level - 1) * 0.2),
                    speed: ENEMY_TYPES[enemyType].speed * (1 + (level - 1) * 0.1),
                    type: enemyType,
                    isBoss: isBoss,
                    bossHealthBar: isBoss ? { width: 60, height: 5 } : null
                };
                if (enemyType >= 2) enemy.dx = (Math.random() - 0.5) * 1;
                enemies.push(enemy);
            }
        }
        
        // 生成掉落道具
        function spawnDroppedPowerup(x, y) {
            if (Math.random() < 0.1) {
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push({
                    x, y,
                    width: 30, height: 30,
                    type,
                    spawnType: POWERUP_SPAWN_TYPE.DROPPED,
                    color: POWERUP_TYPES[type].color,
                    text: POWERUP_TYPES[type].text,
                    speed: 0,
                    targetX: player.x + player.width/2,
                    targetY: player.y + player.height/2
                });
            }
        }
        
        // 生成随机道具
        function spawnRandomPowerup(timestamp) {
            if (timestamp - lastRandomPowerupTime > 5000 && Math.random() < 0.05) {
                lastRandomPowerupTime = timestamp;
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];
                const x = Math.random() * (WIDTH - 30);
                powerups.push({
                    x, y: -30,
                    width: 30, height: 30,
                    type,
                    spawnType: POWERUP_SPAWN_TYPE.RANDOM,
                    color: POWERUP_TYPES[type].color,
                    text: POWERUP_TYPES[type].text,
                    speed: 2,
                    pulse: 0
                });
            }
        }
        
        // 使用特殊技能
        function useSpecial() {
            if (Date.now() - lastSpecialUsed < specialCooldown) return;
            specialCharge = 0;
            lastSpecialUsed = Date.now();
            createExplosion(WIDTH / 2, HEIGHT / 2, 400, true);
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.health -= 5;
                if (enemy.health <= 0) {
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30 + enemy.type * 10);
                    score += enemy.points;
                    updateGameInfo();
                    spawnDroppedPowerup(enemy.x + enemy.width / 2 - 15, enemy.y + enemy.height / 2 - 15);
                    specialCharge = Math.min(specialMaxCharge, specialCharge + 10);
                    enemies.splice(i, 1);
                }
            }
        }
        
        // 绘制玩家
        function drawPlayer() {
            ctx.fillStyle = 'space-blue';
            const scale = 6;
            for (let y = 0; y < player.sprite.length; y++) {
                for (let x = 0; x < player.sprite[y].length; x++) {
                    if (player.sprite[y][x] === 1) {
                        ctx.fillRect(player.x + x * scale, player.y + y * scale, scale - 1, scale - 1);
                    }
                }
            }
            
            // 护盾效果
            if (player.shield > 0) {
                const shieldAlpha = 0.3 + (Math.sin(Date.now() * 0.005) * 0.2);
                ctx.strokeStyle = `rgba(100, 150, 255, ${shieldAlpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(
                    player.x + player.width / 2, player.y + player.height / 2,
                    player.width / 2 + 10, player.height / 2 + 10,
                    0, 0, Math.PI * 2
                );
                ctx.stroke();
                const pulseRadius = player.width / 2 + 15 + Math.sin(Date.now() * 0.01) * 3;
                ctx.strokeStyle = `rgba(100, 150, 255, ${shieldAlpha * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(
                    player.x + player.width / 2, player.y + player.height / 2,
                    pulseRadius, pulseRadius, 0, 0, Math.PI * 2
                );
                ctx.stroke();
            }
            
            // 引擎火焰
            const pulse = Math.sin(Date.now() * 0.01) * 5 + 10;
            const engineColor = player.speedBoost > 0 ? 'rgba(255, 0, 255, 0.8)' : 'rgba(255, 150, 50, 0.8)';
            ctx.fillStyle = engineColor;
            ctx.beginPath();
            ctx.moveTo(player.x + 20, player.y + 40);
            ctx.lineTo(player.x + 30, player.y + 40 + pulse);
            ctx.lineTo(player.x + 40, player.y + 40);
            ctx.closePath();
            ctx.fill();
            
            // 引擎粒子
            ctx.fillStyle = player.speedBoost > 0 ? 'rgba(255, 100, 255, 0.7)' : 'rgba(255, 200, 100, 0.7)';
            for (let i = 0; i < 3; i++) {
                const offset = Math.sin(Date.now() * 0.01 + i) * 2;
                ctx.beginPath();
                ctx.arc(player.x + 25 + i * 10, player.y + 40 + pulse / 2 + offset, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 绘制子弹
        function drawBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y -= BULLET_SPEED;
                if (bullet.angle) {
                    bullet.x += Math.tan(bullet.angle) * BULLET_SPEED * 0.5;
                }
                
                const { width, height, color } = bulletType;
                ctx.fillStyle = color;
                ctx.fillRect(bullet.x, bullet.y, width, height);
                
                // 尖端
                ctx.beginPath();
                ctx.moveTo(bullet.x + width / 2, bullet.y);
                ctx.lineTo(bullet.x, bullet.y + 5);
                ctx.lineTo(bullet.x + width, bullet.y + 5);
                ctx.closePath();
                ctx.fill();
                
                // 尾迹
                for (let j = 0; j < 10; j++) {
                    ctx.fillStyle = `rgba(${parseInt(color.substring(1, 3), 16)}, 
                                         ${parseInt(color.substring(3, 5), 16)}, 
                                         ${parseInt(color.substring(5, 7), 16)}, 
                                         ${(10 - j) * 0.1})`;
                    ctx.fillRect(bullet.x, bullet.y + height + j, width, 1);
                }
                
                // 子弹特效
                if (bulletType === BULLET_TYPES.UPGRADED) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y + height / 3);
                    ctx.lineTo(bullet.x + width, bullet.y + height / 3);
                    ctx.moveTo(bullet.x, bullet.y + height * 2/3);
                    ctx.lineTo(bullet.x + width, bullet.y + height * 2/3);
                    ctx.stroke();
                }
                if (bulletType === BULLET_TYPES.SPECIAL) {
                    const glowRadius = width / 2 + 2 + Math.sin(Date.now() * 0.02) * 1;
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(bullet.x + width / 2, bullet.y + height / 2, glowRadius, height / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                if (bulletType === BULLET_TYPES.SPREAD) {
                    ctx.fillStyle = 'rgba(200, 100, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(bullet.x + width / 2, bullet.y + height, width * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (bullet.y + height < 0) bullets.splice(i, 1);
            }
        }
        
        // 绘制敌人
        function drawEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += enemy.speed;
                if (enemy.dx) {
                    enemy.x += enemy.dx;
                    if (enemy.x <= 0 || enemy.x + enemy.width >= WIDTH) enemy.dx = -enemy.dx;
                }
                
                // 绘制敌人
                ctx.fillStyle = enemy.color;
                const scale = enemy.width / enemy.sprite[0].length;
                for (let y = 0; y < enemy.sprite.length; y++) {
                    for (let x = 0; x < enemy.sprite[y].length; x++) {
                        if (enemy.sprite[y][x] === 1) {
                            ctx.fillRect(enemy.x + x * scale, enemy.y + y * scale, scale - 1, scale - 1);
                        }
                    }
                }
                
                // BOSS血条
                if (enemy.isBoss && enemy.bossHealthBar) {
                    const healthPercent = enemy.health / (ENEMY_TYPES[3].health * (1 + (level - 1) * 0.2));
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
                    ctx.fillRect(
                        enemy.x + enemy.width / 2 - enemy.bossHealthBar.width / 2,
                        enemy.y - 10,
                        enemy.bossHealthBar.width,
                        enemy.bossHealthBar.height
                    );
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                    ctx.fillRect(
                        enemy.x + enemy.width / 2 - enemy.bossHealthBar.width / 2,
                        enemy.y - 10,
                        enemy.bossHealthBar.width * healthPercent,
                        enemy.bossHealthBar.height
                    );
                }
                
                // 移除超出屏幕的敌人
                if (enemy.y > HEIGHT) {
                    player.health -= 10;
                    updateGameInfo();
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 15);
                    enemies.splice(i, 1);
                    if (player.health <= 0) {
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, 60, true);
                        endGame();
                    }
                }
            }
        }
        
        // 绘制道具
        function drawPowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                if (powerup.spawnType === POWERUP_SPAWN_TYPE.DROPPED) {
                    const dx = player.x + player.width/2 - (powerup.x + 15);
                    const dy = player.y + player.height/2 - (powerup.y + 15);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const speed = 8;
                    
                    powerup.x += (dx / dist) * speed;
                    powerup.y += (dy / dist) * speed;
                    
                    if (dist < 20) {
                        applyPowerupEffect(powerup, i);
                        continue;
                    }
                } else {
                    powerup.y += powerup.speed;
                    powerup.pulse = Math.sin(Date.now() * 0.01) * 3;
                    
                    if (powerup.y > HEIGHT) {
                        powerups.splice(i, 1);
                        continue;
                    }
                }
                
                // 绘制道具
                ctx.fillStyle = `rgba(${parseInt(powerup.color.substring(6, 8), 16)}, 
                                     ${parseInt(powerup.color.substring(9, 11), 16)}, 
                                     ${parseInt(powerup.color.substring(12, 14), 16)}, 
                                     0.3)`;
                ctx.beginPath();
                ctx.ellipse(
                    powerup.x + 15, powerup.y + 15,
                    20 + powerup.pulse, 20 + powerup.pulse,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.fillStyle = powerup.color;
                ctx.fillRect(powerup.x, powerup.y, 30, 30);
                
                ctx.fillStyle = 'space-black';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerup.text, powerup.x + 15, powerup.y + 15);
            }
        }
        
        // 应用道具效果
        function applyPowerupEffect(powerup, index) {
            switch (powerup.type) {
                case 'HEALTH':
                    player.health = Math.min(100, player.health + 30);
                    break;
                case 'SHIELD':
                    player.shield = Math.min(50, player.shield + 20);
                    break;
                case 'SPEED':
                    player.speedBoost = 150;
                    break;
                case 'BULLET_UPGRADE':
                    if (bulletType === BULLET_TYPES.NORMAL) {
                        bulletType = BULLET_TYPES.UPGRADED;
                    } else if (bulletType === BULLET_TYPES.UPGRADED) {
                        bulletType = BULLET_TYPES.SPREAD;
                        player.bulletSpread = 3;
                    } else if (bulletType === BULLET_TYPES.SPREAD) {
                        bulletType = BULLET_TYPES.SPECIAL;
                    }
                    break;
                case 'SPECIAL_CHARGE':
                    specialCharge = Math.min(specialMaxCharge, specialCharge + 30);
                    break;
            }
            
            createExplosion(powerup.x + 15, powerup.y + 15, 20);
            updateGameInfo();
            powerups.splice(index, 1);
        }
        
        // 创建爆炸效果
        function createExplosion(x, y, radius, isPlayer = false) {
            const colorChoices = [[255, 80, 80], [255, 150, 50], [180, 50, 255]];
            const color = isPlayer ? [50, 200, 255] : colorChoices[Math.floor(Math.random() * colorChoices.length)];
            
            explosions.push({
                x, y, radius: 0, maxRadius: radius, alpha: 1, color, particles: []
            });
            
            const particleCount = Math.floor(radius / 3);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1;
                const particleRadius = Math.random() * 3 + 1;
                
                explosions[explosions.length - 1].particles.push({
                    x: 0, y: 0, radius: particleRadius,
                    color: `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${Math.random() * 0.5 + 0.5})`,
                    vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 20
                });
            }
        }
        
        // 绘制爆炸效果
        function drawExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.radius += 2;
                explosion.alpha -= 0.03;
                
                if (explosion.alpha > 0) {
                    const gradient = ctx.createRadialGradient(
                        explosion.x, explosion.y, 0, explosion.x, explosion.y, explosion.radius
                    );
                    gradient.addColorStop(0, `rgba(${explosion.color[0]}, ${explosion.color[1]}, ${explosion.color[2]}, ${explosion.alpha * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(${explosion.color[0]}, ${explosion.color[1]}, ${explosion.color[2]}, ${explosion.alpha * 0.4})`);
                    gradient.addColorStop(1, `rgba(${explosion.color[0]}, ${explosion.color[1]}, ${explosion.color[2]}, 0)`);
                    
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
                
                for (let j = explosion.particles.length - 1; j >= 0; j--) {
                    const particle = explosion.particles[j];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    
                    const lifeFactor = particle.life / 50;
                    ctx.beginPath();
                    ctx.arc(explosion.x + particle.x, explosion.y + particle.y, particle.radius, 0, Math.PI * 2);
                    const rgba = particle.color.match(/\d+/g);
                    ctx.fillStyle = `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${lifeFactor})`;
                    ctx.fill();
                    
                    if (particle.life <= 0) explosion.particles.splice(j, 1);
                }
                
                if (explosion.alpha <= 0 && explosion.particles.length === 0) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        // 检测碰撞
        function checkCollisions() {
            // 子弹与敌人碰撞
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bulletType.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bulletType.height > enemy.y
                    ) {
                        enemy.health -= bulletType.damage;
                        specialCharge = Math.min(specialMaxCharge, specialCharge + 1);
                        bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30 + enemy.type * 10);
                            score += enemy.points;
                            updateGameInfo();
                            spawnDroppedPowerup(enemy.x + enemy.width / 2 - 15, enemy.y + enemy.height / 2 - 15);
                            enemies.splice(j, 1);
                        } else {
                            createExplosion(bullet.x + bulletType.width / 2, bullet.y + bulletType.height / 2, 5 + bulletType.damage * 2);
                        }
                        break;
                    }
                }
            }
            
            // 玩家与敌人碰撞
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (
                    player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y
                ) {
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30 + enemy.type * 10);
                    enemies.splice(i, 1);
                    
                    let damage = 20;
                    if (player.shield > 0) {
                        const absorb = Math.min(damage, player.shield);
                        player.shield -= absorb;
                        damage -= absorb;
                    }
                    player.health -= damage;
                    updateGameInfo();
                    
                    if (player.health <= 0) {
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, 60, true);
                        endGame();
                    }
                }
            }
            
            // 玩家与随机道具碰撞
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                if (powerup.spawnType !== POWERUP_SPAWN_TYPE.RANDOM) continue;
                
                if (
                    player.x < powerup.x + powerup.width &&
                    player.x + player.width > powerup.x &&
                    player.y < powerup.y + powerup.height &&
                    player.y + player.height > powerup.y
                ) {
                    applyPowerupEffect(powerup, i);
                }
            }
        }
        
        // 处理玩家输入
        function handlePlayer() {
            const currentSpeed = player.speedBoost > 0 ? player.speed * 1.5 : player.speed;
            
            // 平滑移动控制
            if (keys['ArrowLeft']) {
                moveVelocityX = Math.max(moveVelocityX - MOVE_ACCELERATION, -currentSpeed);
            } else if (keys['ArrowRight']) {
                moveVelocityX = Math.min(moveVelocityX + MOVE_ACCELERATION, currentSpeed);
            } else {
                moveVelocityX *= MOVE_FRICTION;
                if (Math.abs(moveVelocityX) < 0.1) moveVelocityX = 0;
            }
            
            if (keys['ArrowUp']) {
                moveVelocityY = Math.max(moveVelocityY - MOVE_ACCELERATION, -currentSpeed);
            } else if (keys['ArrowDown']) {
                moveVelocityY = Math.min(moveVelocityY + MOVE_ACCELERATION, currentSpeed);
            } else {
                moveVelocityY *= MOVE_FRICTION;
                if (Math.abs(moveVelocityY) < 0.1) moveVelocityY = 0;
            }
            
            // 应用移动
            player.x += moveVelocityX;
            player.y += moveVelocityY;
            
            // 边界检查
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > WIDTH) player.x = WIDTH - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > HEIGHT) player.y = HEIGHT - player.height;
            
            // 键盘射击控制
            if (keys['Space'] && Date.now() - player.lastShot > player.shootDelay) {
                player.lastShot = Date.now();
                shootBullet();
            }
            
            // 减少效果持续时间
            if (player.speedBoost > 0) player.speedBoost--;
        }
        
        // 游戏主循环
        function gameLoop(timestamp) {
            if (gameOver || gamePaused) return;
            
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            drawStars();
            spawnEnemy(timestamp);
            spawnRandomPowerup(timestamp);
            handlePlayer();
            drawPlayer();
            drawBullets();
            drawEnemies();
            drawPowerups();
            drawExplosions();
            checkCollisions();
            
            // 更新特殊技能能量
            specialCharge = Math.min(specialMaxCharge, specialCharge + 0.05);
            
            // 绘制特殊技能冷却提示
            if (Date.now() - lastSpecialUsed < specialCooldown) {
                const cooldownPercent = 1 - (Date.now() - lastSpecialUsed) / specialCooldown;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(player.x + player.width / 2 - 20, player.y - 30, 40, 5);
                ctx.fillStyle = 'rgba(255, 150, 50, 0.8)';
                ctx.fillRect(player.x + player.width / 2 - 20, player.y - 30, 40 * cooldownPercent, 5);
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 初始化游戏
        window.addEventListener('load', init);
    </script>
</body>
</html>
