<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>太空射击 - 网页版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        space: {
                            black: '#00000A',
                            blue: '#32C8FF',
                            red: '#FF5050',
                            orange: '#FF9632',
                            purple: '#B432FF',
                            yellow: '#FFFF00',
                            shield: '#6496FF',
                            health: '#32FF64',
                            speed: '#FFC832',
                            bullet: '#FFD700',
                            special: '#FF00FF'
                        }
                    },
                    fontFamily: {
                        game: ['Arial', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            }
            .glow {
                filter: drop-shadow(0 0 5px currentColor);
            }
            .pulse {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
            .particle {
                position: absolute;
                border-radius: 50%;
                pointer-events: none;
            }
        }
    </style>
</head>
<body class="bg-space-black overflow-hidden m-0 p-0 font-game text-white">
    <div id="game-container" class="relative w-full h-screen flex flex-col items-center justify-center">
        <!-- 星空背景 -->
        <div id="stars" class="absolute inset-0 z-0"></div>
        
        <!-- 游戏画布 -->
        <canvas id="game-canvas" class="z-10 border-2 border-white/20 rounded-md shadow-lg"></canvas>
        
        <!-- 游戏信息 -->
        <div id="game-info" class="absolute top-4 left-4 z-20 bg-space-black/60 backdrop-blur-sm p-3 rounded-lg border border-white/20">
            <div class="flex items-center mb-2">
                <i class="fa fa-star text-yellow-400 mr-2"></i>
                <span id="score">分数: 0</span>
            </div>
            <div class="flex items-center mb-2">
                <i class="fa fa-signal text-space-blue mr-2"></i>
                <span id="level">等级: 1</span>
            </div>
            <div class="flex items-center">
                <i class="fa fa-bolt text-space-orange mr-2"></i>
                <span id="special">技能: <span id="special-charge">0</span>/<span id="special-max">100</span></span>
            </div>
        </div>
        
        <!-- 玩家状态 -->
        <div id="player-status" class="absolute bottom-4 left-4 z-20 bg-space-black/60 backdrop-blur-sm p-3 rounded-lg border border-white/20">
            <div class="flex items-center mb-2">
                <div class="w-32 bg-gray-700 rounded-full h-2.5 mr-2">
                    <div id="health-bar" class="bg-space-health h-2.5 rounded-full" style="width: 100%"></div>
                </div>
                <span id="health-text">100</span>
            </div>
            <div class="flex items-center">
                <div class="w-32 bg-gray-700 rounded-full h-2.5 mr-2">
                    <div id="shield-bar" class="bg-space-shield h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <span id="shield-text">0</span>
            </div>
        </div>
        
        <!-- 控制提示 -->
        <div id="controls" class="absolute bottom-4 right-4 z-20 bg-space-black/60 backdrop-blur-sm p-3 rounded-lg border border-white/20 text-sm">
            <div class="flex items-center mb-2">
                <span class="px-2 py-1 bg-gray-700 rounded mr-2">← → ↑ ↓</span>
                <span>移动</span>
            </div>
            <div class="flex items-center mb-2">
                <span class="px-2 py-1 bg-gray-700 rounded mr-2">空格</span>
                <span>射击</span>
            </div>
            <div class="flex items-center">
                <span class="px-2 py-1 bg-space-orange rounded mr-2">X</span>
                <span>使用技能</span>
            </div>
        </div>
        
        <!-- 开始菜单 -->
        <div id="start-menu" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-space-black/80 backdrop-blur-sm">
            <h1 class="text-[clamp(2.5rem,8vw,5rem)] font-bold text-space-blue mb-10 text-shadow">星际射手</h1>
            <div class="space-y-4 text-xl text-center max-w-md px-4">
                <div class="flex items-center justify-center">
                    <i class="fa fa-arrow-left text-space-blue mr-2"></i>
                    <i class="fa fa-arrow-right text-space-blue mx-2"></i>
                    <i class="fa fa-arrow-up text-space-blue mx-2"></i>
                    <i class="fa fa-arrow-down text-space-blue ml-2"></i>
                    <span class="ml-4">移动飞船</span>
                </div>
                <div class="flex items-center justify-center">
                    <i class="fa fa-space-shuttle text-space-yellow mr-2"></i>
                    <span>空格键 发射激光</span>
                </div>
                <div class="flex items-center justify-center">
                    <i class="fa fa-bolt text-space-orange mr-2"></i>
                    <span>X键 使用特殊技能</span>
                </div>
                <button id="start-button" class="mt-8 px-8 py-3 bg-space-blue hover:bg-space-blue/80 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                    开始游戏
                </button>
            </div>
        </div>
        
        <!-- 游戏结束菜单 -->
        <div id="game-over" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-space-black/80 backdrop-blur-sm hidden">
            <h1 class="text-[clamp(2.5rem,8vw,5rem)] font-bold text-space-red mb-6 text-shadow">游戏结束</h1>
            <p class="text-2xl mb-2">最终得分: <span id="final-score">0</span></p>
            <p class="text-xl mb-8">等级: <span id="final-level">1</span></p>
            <button id="restart-button" class="px-8 py-3 bg-space-blue hover:bg-space-blue/80 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                重新开始
            </button>
        </div>
        
        <!-- 暂停菜单 -->
        <div id="pause-menu" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-space-black/80 backdrop-blur-sm hidden">
            <h1 class="text-[clamp(2.5rem,8vw,5rem)] font-bold text-space-blue mb-10 text-shadow">游戏暂停</h1>
            <button id="resume-button" class="mt-4 px-8 py-3 bg-space-blue hover:bg-space-blue/80 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                继续游戏
            </button>
            <button id="restart-button-pause" class="mt-4 px-8 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-white font-bold transition-all transform hover:scale-105 hover:shadow-lg">
                重新开始
            </button>
        </div>
    </div>

    <script>
        // 游戏常量 - 调整敌机速度和玩家射击间隔
        const WIDTH = 800;
        const HEIGHT = 600;
        const PLAYER_SPEED = 6.5; // 保持玩家速度不变
        const BULLET_SPEED = 10;
        const ENEMY_SPEED_FACTOR = 0.8; // 敌机速度降低20%
        
        // 敌机类型定义 - 调整速度
        const ENEMY_TYPES = [
            { 
                width: 40, 
                height: 36, 
                color: 'space-red', 
                health: 1, 
                points: 10, 
                speed: 2 * ENEMY_SPEED_FACTOR, // 调整后速度
                sprite: [
                    [0,0,1,1,0,0],
                    [0,1,1,1,1,0],
                    [1,1,1,1,1,1],
                    [1,1,0,0,1,1],
                    [0,1,0,0,1,0],
                    [0,0,1,1,0,0]
                ]
            },
            { 
                width: 32, 
                height: 28, 
                color: 'space-orange', 
                health: 1, 
                points: 15, 
                speed: 3.5 * ENEMY_SPEED_FACTOR, // 调整后速度
                sprite: [
                    [0,1,1,1,1,0],
                    [1,1,1,1,1,1],
                    [1,1,0,0,1,1],
                    [0,1,1,1,1,0],
                    [0,0,1,1,0,0]
                ]
            },
            { 
                width: 56, 
                height: 48, 
                color: 'space-purple', 
                health: 3, 
                points: 25, 
                speed: 1.5 * ENEMY_SPEED_FACTOR, // 调整后速度
                sprite: [
                    [0,0,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1],
                    [1,1,0,1,1,0,1,1],
                    [1,1,0,1,1,0,1,1],
                    [1,1,1,1,1,1,1,1],
                    [0,1,1,0,0,1,1,0],
                    [0,0,1,1,1,1,0,0]
                ]
            },
            { 
                width: 72, 
                height: 64, 
                color: 'space-blue', 
                health: 10, 
                points: 100, 
                speed: 1 * ENEMY_SPEED_FACTOR, // 调整后速度
                sprite: [
                    [0,0,0,1,1,1,1,0,0,0],
                    [0,0,1,1,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,1,1,0],
                    [1,1,1,0,1,1,0,1,1,1],
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,1,1,1,0,0,1,1,1,1],
                    [1,1,0,0,0,0,0,0,1,1],
                    [0,1,0,0,0,0,0,0,1,0],
                    [0,0,1,1,0,0,1,1,0,0],
                    [0,0,0,1,1,1,1,0,0,0]
                ]
            }
        ];
        
        // 道具类型与生成类型
        const POWERUP_TYPES = {
            HEALTH: { color: 'space-health', text: 'H' },
            SHIELD: { color: 'space-shield', text: 'S' },
            SPEED: { color: 'space-speed', text: 'F' },
            BULLET_UPGRADE: { color: 'space-yellow', text: 'B' },
            SPECIAL_CHARGE: { color: 'space-orange', text: 'P' }
        };
        
        const POWERUP_SPAWN_TYPE = {
            DROPPED: 'dropped', // 敌机掉落（自动吸收）
            RANDOM: 'random'    // 随机生成（手动拾取）
        };
        
        // 子弹类型
        const BULLET_TYPES = {
            NORMAL: { width: 6, height: 20, color: 'space-yellow', damage: 1 },
            UPGRADED: { width: 8, height: 24, color: 'space-blue', damage: 2 },
            SPECIAL: { width: 12, height: 30, color: 'space-special', damage: 5 },
            SPREAD: { width: 7, height: 22, color: 'space-purple', damage: 1.5 }
        };
        
        // 游戏变量
        let canvas, ctx;
        let player, bullets, enemies, explosions, powerups, planets, asteroids;
        let score, level, gameOver, lastEnemySpawn, enemySpawnRate, gamePaused;
        let keys = {};
        let stars = [];
        let animationId;
        let bulletType = BULLET_TYPES.NORMAL;
        let specialCharge = 0;
        let specialMaxCharge = 100;
        let lastSpecialUsed = 0;
        let specialCooldown = 5000; // 5秒冷却
        let lastRandomPowerupTime = 0; // 记录上次随机道具生成时间
        
        // 平滑移动变量
        let moveVelocityX = 0;
        let moveVelocityY = 0;
        const MOVE_ACCELERATION = 0.5;
        const MOVE_FRICTION = 0.8;
        
        // 初始化游戏
        function init() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            
            // 初始化游戏状态
            score = 0;
            level = 1;
            gameOver = false;
            gamePaused = false;
            lastEnemySpawn = 0;
            enemySpawnRate = 1500;
            specialCharge = 0;
            
            // 创建玩家 - 调整射击间隔
            player = {
                x: WIDTH / 2 - 30,
                y: HEIGHT - 80,
                width: 60,
                height: 50,
                speed: PLAYER_SPEED,
                health: 100,
                shield: 0,
                shootDelay: 180, // 从250ms减少到180ms，提高射击频率
                lastShot: 0,
                speedBoost: 0,
                bulletUpgrade: 0,
                bulletSpread: 1,
                specialCharge: 0,
                specialMaxCharge: 100,
                sprite: [
                    [0,0,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,0,0,1,1,1],
                    [1,1,0,0,0,0,1,1],
                    [1,0,0,0,0,0,0,1],
                    [0,0,1,0,0,1,0,0],
                    [0,0,1,0,0,1,0,0],
                    [0,0,0,1,1,0,0,0]
                ]
            };
            
            // 初始化数组
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            planets = []; // 初始化行星数组
            asteroids = []; // 初始化小行星带
            
            // 创建星空、行星背景和小行星带
            createStars();
            createPlanets();
            createAsteroids();
            
            // 绑定按键事件
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Escape') togglePause();
                if (e.code === 'KeyX' && specialCharge >= specialMaxCharge && !gameOver && !gamePaused) {
                    useSpecial();
                }
            });
            window.addEventListener('keyup', (e) => keys[e.code] = false);
            
            // 绑定按钮事件
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            document.getElementById('restart-button-pause').addEventListener('click', restartGame);
            document.getElementById('resume-button').addEventListener('click', togglePause);
            
            // 开始游戏循环
            gameLoop();
        }
        
        // 创建星空背景
        function createStars() {
            stars = [];
            for (let i = 0; i < 300; i++) {
                stars.push({
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    radius: Math.random() * 1.5,
                    speed: Math.random() * 0.5 + 0.1,
                    color: `rgba(${Math.random() * 200 + 55}, ${Math.random() * 200 + 55}, ${Math.random() * 255}, ${Math.random() * 0.7 + 0.3})`
                });
            }
            // 大星星点缀
            for (let i = 0; i < 20; i++) {
                stars.push({
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    radius: Math.random() * 2 + 1.5,
                    speed: Math.random() * 0.2 + 0.05,
                    color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 0.5 + 0.5})`,
                    blink: Math.random() > 0.5,
                    blinkPhase: Math.random() * Math.PI * 2
                });
            }
        }
        
        // 创建行星
        function createPlanets() {
            planets = [
                {x: WIDTH * 0.2, y: HEIGHT * 0.3, radius: 30, color: '#FFD740', speed: 0.02, hasRing: false}, // 柔和金色
                {x: WIDTH * 0.7, y: HEIGHT * 0.2, radius: 20, color: '#4FC3F7', speed: 0.015, hasRing: true}, // 柔和蓝色
                {x: WIDTH * 0.85, y: HEIGHT * 0.6, radius: 25, color: '#B39DDB', speed: 0.01, hasRing: false}, // 柔和紫色
                {x: WIDTH * 0.1, y: HEIGHT * 0.8, radius: 15, color: '#EF9A9A', speed: 0.025, hasRing: false}  // 柔和红色
            ];
        }
        
        // 创建小行星带
        function createAsteroids() {
            asteroids = [];
            // 创建小行星带（位于画面中间偏右）
            for (let i = 0; i < 50; i++) {
                asteroids.push({
                    x: WIDTH * 0.6 + Math.random() * WIDTH * 0.3,
                    y: HEIGHT * 0.3 + Math.random() * HEIGHT * 0.4,
                    radius: Math.random() * 3 + 1,
                    speed: (Math.random() - 0.5) * 0.2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    color: `rgba(${80 + Math.random() * 40}, ${80 + Math.random() * 40}, ${100 + Math.random() * 50}, 0.7)`
                });
            }
        }
        
        // 绘制星空背景 - 新增行星和小行星带绘制
        function drawStars() {
            ctx.fillStyle = '#0A0A1A'; // 更深邃的背景色
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // 绘制星云（更柔和的色调）
            drawNebula();
            
            // 绘制小行星带
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.speed;
                asteroid.rotation += asteroid.rotationSpeed;
                
                // 小行星带循环移动
                if (asteroid.x > WIDTH * 0.9 + 50) asteroid.x = WIDTH * 0.6 - 50;
                if (asteroid.x < WIDTH * 0.6 - 50) asteroid.x = WIDTH * 0.9 + 50;
                
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);
                ctx.fillStyle = asteroid.color;
                ctx.beginPath();
                // 不规则小行星形状
                ctx.moveTo(0, -asteroid.radius);
                ctx.lineTo(asteroid.radius * 0.8, -asteroid.radius * 0.3);
                ctx.lineTo(asteroid.radius * 0.5, asteroid.radius * 0.7);
                ctx.lineTo(-asteroid.radius * 0.6, asteroid.radius * 0.5);
                ctx.lineTo(-asteroid.radius * 0.7, -asteroid.radius * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });
            
            // 绘制行星（增加表面纹理）
            planets.forEach(planet => {
                planet.x = (planet.x + planet.speed) % (WIDTH + 100) - 50;
                
                // 行星主体渐变
                const gradient = ctx.createRadialGradient(
                    planet.x - planet.radius * 0.2, 
                    planet.y - planet.radius * 0.2, 
                    0,
                    planet.x, 
                    planet.y, 
                    planet.radius
                );
                gradient.addColorStop(0, `${planet.color}FF`);
                gradient.addColorStop(0.7, `${planet.color}CC`);
                gradient.addColorStop(1, `${planet.color}40`);
                ctx.beginPath();
                ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // 行星表面纹理
                if (planet.radius > 20) {
                    ctx.fillStyle = `${planet.color}30`;
                    for (let i = 0; i < 5; i++) {
                        const spotRadius = Math.random() * planet.radius * 0.2 + 2;
                        ctx.beginPath();
                        ctx.arc(
                            planet.x + (Math.random() - 0.5) * planet.radius * 0.8,
                            planet.y + (Math.random() - 0.5) * planet.radius * 0.8,
                            spotRadius, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                // 行星光环（降低透明度）
                if (planet.hasRing) {
                    ctx.strokeStyle = `${planet.color}20`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(
                        planet.x, planet.y, 
                        planet.radius * 1.8, planet.radius * 0.6, 
                        0, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    // 光环内侧细环
                    ctx.strokeStyle = `${planet.color}30`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(
                        planet.x, planet.y, 
                        planet.radius * 1.5, planet.radius * 0.5, 
                        0, 0, Math.PI * 2
                    );
                    ctx.stroke();
                }
            });
            
            // 绘制星星（分层闪烁）
            stars.forEach(star => {
                star.y += star.speed;
                if (star.blink) {
                    star.blinkPhase += 0.05;
                    const alpha = 0.4 + Math.sin(star.blinkPhase) * 0.6; // 更自然的闪烁
                    const colorParts = star.color.match(/\d+/g);
                    star.currentColor = `rgba(${colorParts[0]}, ${colorParts[1]}, ${colorParts[2]}, ${alpha})`;
                }
                if (star.y > HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * WIDTH;
                }
                
                // 星星光晕（增强层次感）
                if (star.radius > 1.5) {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = star.blink ? `${star.currentColor}20` : `${star.color}20`;
                    ctx.fill();
                }
                
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.blink ? star.currentColor : star.color;
                ctx.fill();
            });
        }
        
        // 添加星云背景
        function drawNebula() {
            // 主星云（靛蓝色）
            const gradient1 = ctx.createRadialGradient(
                WIDTH * 0.3, HEIGHT * 0.2, 50,
                WIDTH * 0.3, HEIGHT * 0.2, 300
            );
            gradient1.addColorStop(0, 'rgba(100, 100, 200, 0.05)');
            gradient1.addColorStop(1, 'rgba(100, 100, 200, 0)');
            
            // 副星云（蓝紫色）
            const gradient2 = ctx.createRadialGradient(
                WIDTH * 0.7, HEIGHT * 0.7, 70,
                WIDTH * 0.7, HEIGHT * 0.7, 350
            );
            gradient2.addColorStop(0, 'rgba(120, 80, 180, 0.07)');
            gradient2.addColorStop(1, 'rgba(120, 80, 180, 0)');
            
            // 背景星云（深蓝色）
            const gradient3 = ctx.createRadialGradient(
                WIDTH * 0.5, HEIGHT * 0.5, 100,
                WIDTH * 0.5, HEIGHT * 0.5, 400
            );
            gradient3.addColorStop(0, 'rgba(50, 50, 120, 0.05)');
            gradient3.addColorStop(1, 'rgba(50, 50, 120, 0)');
            
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = gradient2;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = gradient3;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }
        
        // 开始游戏
        function startGame() {
            document.getElementById('start-menu').classList.add('hidden');
            gameOver = false;
            score = 0;
            level = 1;
            player.health = 100;
            player.shield = 0;
            bulletType = BULLET_TYPES.NORMAL;
            player.bulletSpread = 1;
            specialCharge = 0;
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            updateGameInfo();
            
            // 确保游戏循环启动
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 重新开始游戏
        function restartGame() {
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('pause-menu').classList.add('hidden');
            
            // 重置游戏状态
            gameOver = false;
            gamePaused = false; // 确保暂停状态也被重置
            score = 0;
            level = 1;
            player.health = 100;
            player.shield = 0;
            player.x = WIDTH / 2 - 30;
            player.y = HEIGHT - 80;
            bulletType = BULLET_TYPES.NORMAL;
            player.bulletSpread = 1;
            specialCharge = 0;
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            lastEnemySpawn = 0; // 重置敌人生成计时器
            lastRandomPowerupTime = 0; // 重置道具生成计时器
            moveVelocityX = 0; // 重置平滑移动速度
            moveVelocityY = 0;
            
            updateGameInfo();
            
            // 关键修复：重新启动游戏循环
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 暂停/继续游戏
        function togglePause() {
            if (gameOver) return;
            gamePaused = !gamePaused;
            if (gamePaused) {
                document.getElementById('pause-menu').classList.remove('hidden');
                cancelAnimationFrame(animationId);
            } else {
                document.getElementById('pause-menu').classList.add('hidden');
                animationId = requestAnimationFrame(gameLoop);
            }
        }
        
        // 游戏结束
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('final-level').textContent = level;
            document.getElementById('game-over').classList.remove('hidden');
            cancelAnimationFrame(animationId);
        }
        
        // 更新游戏信息
        function updateGameInfo() {
            document.getElementById('score').textContent = `分数: ${score}`;
            document.getElementById('level').textContent = `等级: ${level}`;
            document.getElementById('special-charge').textContent = Math.floor(specialCharge);
            document.getElementById('health-text').textContent = Math.floor(player.health);
            document.getElementById('shield-text').textContent = Math.floor(player.shield);
            document.getElementById('health-bar').style.width = `${player.health}%`;
            document.getElementById('shield-bar').style.width = `${player.shield / 50 * 100}%`;
        }
        
        // 生成敌人
        function spawnEnemy(timestamp) {
            if (gameOver || gamePaused) return;
            if (timestamp - lastEnemySpawn > enemySpawnRate) {
                lastEnemySpawn = timestamp;
                level = 1 + Math.floor(score / 600);
                enemySpawnRate = Math.max(500, 1500 - (level - 1) * 100);
                const isBoss = Math.random() < 0.1 && level >= 3;
                const enemyType = isBoss ? 3 : Math.random() < 0.7 ? 0 : Math.random() < 0.9 ? 1 : 2;
                const enemy = {
                    ...ENEMY_TYPES[enemyType],
                    x: Math.random() * (WIDTH - ENEMY_TYPES[enemyType].width),
                    y: -ENEMY_TYPES[enemyType].height,
                    health: ENEMY_TYPES[enemyType].health * (1 + (level - 1) * 0.2),
                    speed: ENEMY_TYPES[enemyType].speed * (1 + (level - 1) * 0.1),
                    type: enemyType,
                    isBoss: isBoss,
                    bossHealthBar: isBoss ? { width: 60, height: 5 } : null
                };
                if (enemyType >= 2) enemy.dx = (Math.random() - 0.5) * 1;
                enemies.push(enemy);
            }
        }
        
        // 道具生成机制优化
        // 1. 敌机掉落道具（10%概率，自动吸收）
        function spawnDroppedPowerup(x, y) {
            if (Math.random() < 0.1) { // 10%掉落概率
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push({
                    x, y,
                    width: 30, height: 30,
                    type,
                    spawnType: POWERUP_SPAWN_TYPE.DROPPED, // 标记为掉落型
                    color: POWERUP_TYPES[type].color,
                    text: POWERUP_TYPES[type].text,
                    speed: 0, // 初始不移动
                    targetX: player.x + player.width/2,
                    targetY: player.y + player.height/2
                });
            }
        }
        
        // 2. 随机生成道具（5%概率，手动拾取）
        function spawnRandomPowerup(timestamp) {
            // 每5秒检测一次，5%概率生成
            if (timestamp - lastRandomPowerupTime > 5000 && Math.random() < 0.05) {
                lastRandomPowerupTime = timestamp;
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];
                const x = Math.random() * (WIDTH - 30); // 随机X坐标
                powerups.push({
                    x, y: -30, // 从顶部出现
                    width: 30, height: 30,
                    type,
                    spawnType: POWERUP_SPAWN_TYPE.RANDOM, // 标记为随机型
                    color: POWERUP_TYPES[type].color,
                    text: POWERUP_TYPES[type].text,
                    speed: 2, // 向下移动
                    pulse: 0
                });
            }
        }
        
        // 使用特殊技能
        function useSpecial() {
            if (Date.now() - lastSpecialUsed < specialCooldown) return;
            specialCharge = 0;
            lastSpecialUsed = Date.now();
            createExplosion(WIDTH / 2, HEIGHT / 2, 400, true);
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.health -= 5;
                if (enemy.health <= 0) {
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30 + enemy.type * 10);
                    score += enemy.points;
                    updateGameInfo();
                    spawnDroppedPowerup(enemy.x + enemy.width / 2 - 15, enemy.y + enemy.height / 2 - 15);
                    specialCharge = Math.min(specialMaxCharge, specialCharge + 10);
                    enemies.splice(i, 1);
                }
            }
        }
        
        // 绘制玩家
        function drawPlayer() {
            ctx.fillStyle = 'space-blue';
            const scale = 6;
            for (let y = 0; y < player.sprite.length; y++) {
                for (let x = 0; x < player.sprite[y].length; x++) {
                    if (player.sprite[y][x] === 1) {
                        ctx.fillRect(player.x + x * scale, player.y + y * scale, scale - 1, scale - 1);
                    }
                }
            }
            // 护盾效果
            if (player.shield > 0) {
                const shieldAlpha = 0.3 + (Math.sin(Date.now() * 0.005) * 0.2);
                ctx.strokeStyle = `rgba(100, 150, 255, ${shieldAlpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(
                    player.x + player.width / 2, player.y + player.height / 2,
                    player.width / 2 + 10, player.height / 2 + 10,
                    0, 0, Math.PI * 2
                );
                ctx.stroke();
                const pulseRadius = player.width / 2 + 15 + Math.sin(Date.now() * 0.01) * 3;
                ctx.strokeStyle = `rgba(100, 150, 255, ${shieldAlpha * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(
                    player.x + player.width / 2, player.y + player.height / 2,
                    pulseRadius, pulseRadius, 0, 0, Math.PI * 2
                );
                ctx.stroke();
            }
            // 引擎火焰
            const pulse = Math.sin(Date.now() * 0.01) * 5 + 10;
            const engineColor = player.speedBoost > 0 ? 'rgba(255, 0, 255, 0.8)' : 'rgba(255, 150, 50, 0.8)';
            ctx.fillStyle = engineColor;
            ctx.beginPath();
            ctx.moveTo(player.x + 20, player.y + 40);
            ctx.lineTo(player.x + 30, player.y + 40 + pulse);
            ctx.lineTo(player.x + 40, player.y + 40);
            ctx.closePath();
            ctx.fill();
            // 引擎粒子
            ctx.fillStyle = player.speedBoost > 0 ? 'rgba(255, 100, 255, 0.7)' : 'rgba(255, 200, 100, 0.7)';
            for (let i = 0; i < 3; i++) {
                const offset = Math.sin(Date.now() * 0.01 + i) * 2;
                ctx.beginPath();
                ctx.arc(player.x + 25 + i * 10, player.y + 40 + pulse / 2 + offset, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 绘制子弹
        function drawBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y -= BULLET_SPEED;
                const { width, height, color } = bulletType;
                // 子弹主体
                ctx.fillStyle = color;
                ctx.fillRect(bullet.x, bullet.y, width, height);
                // 尖端
                ctx.beginPath();
                ctx.moveTo(bullet.x + width / 2, bullet.y);
                ctx.lineTo(bullet.x, bullet.y + 5);
                ctx.lineTo(bullet.x + width, bullet.y + 5);
                ctx.closePath();
                ctx.fill();
                // 尾迹
                for (let j = 0; j < 10; j++) {
                    ctx.fillStyle = `rgba(${parseInt(color.substring(1, 3), 16)}, 
                                         ${parseInt(color.substring(3, 5), 16)}, 
                                         ${parseInt(color.substring(5, 7), 16)}, 
                                         ${(10 - j) * 0.1})`;
                    ctx.fillRect(bullet.x, bullet.y + height + j, width, 1);
                }
                // 子弹特效（不同类型）
                if (bulletType === BULLET_TYPES.UPGRADED) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y + height / 3);
                    ctx.lineTo(bullet.x + width, bullet.y + height / 3);
                    ctx.moveTo(bullet.x, bullet.y + height * 2/3);
                    ctx.lineTo(bullet.x + width, bullet.y + height * 2/3);
                    ctx.stroke();
                }
                if (bulletType === BULLET_TYPES.SPECIAL) {
                    const glowRadius = width / 2 + 2 + Math.sin(Date.now() * 0.02) * 1;
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(bullet.x + width / 2, bullet.y + height / 2, glowRadius, height / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                if (bulletType === BULLET_TYPES.SPREAD) {
                    ctx.fillStyle = 'rgba(200, 100, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(bullet.x + width / 2, bullet.y + height, width * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                // 移除超出屏幕的子弹
                if (bullet.y + height < 0) bullets.splice(i, 1);
            }
        }
        
        // 绘制敌人
        function drawEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += enemy.speed;
                if (enemy.dx) {
                    enemy.x += enemy.dx;
                    if (enemy.x <= 0 || enemy.x + enemy.width >= WIDTH) enemy.dx = -enemy.dx;
                }
                // 绘制敌人
                ctx.fillStyle = enemy.color;
                const scale = enemy.width / enemy.sprite[0].length;
                                for (let y = 0; y < enemy.sprite.length; y++) {
                    for (let x = 0; x < enemy.sprite[y].length; x++) {
                        if (enemy.sprite[y][x] === 1) {
                            ctx.fillRect(enemy.x + x * scale, enemy.y + y * scale, scale - 1, scale - 1);
                        }
                    }
                }
                
                // 敌人发光效果
                const glowAlpha = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
                ctx.strokeStyle = `rgba(${parseInt(enemy.color.substring(6, 8), 16)}, 
                                      ${parseInt(enemy.color.substring(9, 11), 16)}, 
                                      ${parseInt(enemy.color.substring(12, 14), 16)}, 
                                      ${glowAlpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
                ctx.stroke();
                
                // 敌人BOSS血条
                if (enemy.isBoss && enemy.bossHealthBar) {
                    const healthPercent = enemy.health / (ENEMY_TYPES[3].health * (1 + (level - 1) * 0.2));
                    // 血条背景
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
                    ctx.fillRect(
                        enemy.x + enemy.width / 2 - enemy.bossHealthBar.width / 2,
                        enemy.y - 10,
                        enemy.bossHealthBar.width,
                        enemy.bossHealthBar.height
                    );
                    // 血条
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                    ctx.fillRect(
                        enemy.x + enemy.width / 2 - enemy.bossHealthBar.width / 2,
                        enemy.y - 10,
                        enemy.bossHealthBar.width * healthPercent,
                        enemy.bossHealthBar.height
                    );
                }
                
                // 移除超出屏幕的敌人
                if (enemy.y > HEIGHT) enemies.splice(i, 1);
            }
        }
        
        // 绘制道具
        function drawPowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                // 处理不同类型道具的移动逻辑
                if (powerup.spawnType === POWERUP_SPAWN_TYPE.DROPPED) {
                    // 掉落型道具：向玩家移动
                    const dx = powerup.targetX - (powerup.x + powerup.width/2);
                    const dy = powerup.targetY - (powerup.y + powerup.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 2) {
                        powerup.x += dx / distance * 3;
                        powerup.y += dy / distance * 3;
                    } else {
                        // 到达玩家位置，立即生效
                        applyPowerupEffect(powerup, i);
                        continue;
                    }
                } else {
                    // 随机型道具：向下移动
                    powerup.y += powerup.speed;
                    // 脉冲效果
                    powerup.pulse = Math.sin(Date.now() * 0.01) * 2;
                    
                    // 移除超出屏幕的道具
                    if (powerup.y > HEIGHT) powerups.splice(i, 1);
                }
                
                // 绘制道具
                ctx.fillStyle = `rgba(${parseInt(powerup.color.substring(6, 8), 16)}, 
                                     ${parseInt(powerup.color.substring(9, 11), 16)}, 
                                     ${parseInt(powerup.color.substring(12, 14), 16)}, 
                                     0.8)`;
                
                // 道具主体（圆形）
                ctx.beginPath();
                ctx.arc(
                    powerup.x + powerup.width / 2, 
                    powerup.y + powerup.height / 2, 
                    powerup.width / 2 + powerup.pulse, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // 道具内部符号
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerup.text, 
                    powerup.x + powerup.width / 2, 
                    powerup.y + powerup.height / 2
                );
                
                // 道具光芒
                ctx.strokeStyle = `rgba(${parseInt(powerup.color.substring(6, 8), 16)}, 
                                       ${parseInt(powerup.color.substring(9, 11), 16)}, 
                                       ${parseInt(powerup.color.substring(12, 14), 16)}, 
                                       0.5)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(
                    powerup.x + powerup.width / 2, 
                    powerup.y + powerup.height / 2, 
                    powerup.width / 2 + 5 + Math.sin(Date.now() * 0.01) * 2, 
                    0, Math.PI * 2
                );
                ctx.stroke();
                
                // 碰撞检测（仅随机型道具需要手动拾取）
                if (powerup.spawnType === POWERUP_SPAWN_TYPE.RANDOM) {
                    if (
                        player.x < powerup.x + powerup.width &&
                        player.x + player.width > powerup.x &&
                        player.y < powerup.y + powerup.height &&
                        player.y + player.height > powerup.y
                    ) {
                        applyPowerupEffect(powerup, i);
                    }
                }
            }
        }
        
        // 应用道具效果
        function applyPowerupEffect(powerup, index) {
            switch(powerup.type) {
                case 'HEALTH':
                    player.health = Math.min(100, player.health + 25);
                    createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '生命+25');
                    break;
                case 'SHIELD':
                    player.shield = Math.min(50, player.shield + 15);
                    createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '护盾+15');
                    break;
                case 'SPEED':
                    player.speedBoost = 300; // 持续时间（帧）
                    player.speed = PLAYER_SPEED * 1.5;
                    createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '速度提升');
                    break;
                case 'BULLET_UPGRADE':
                    if (bulletType === BULLET_TYPES.NORMAL) {
                        bulletType = BULLET_TYPES.UPGRADED;
                        createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '子弹升级');
                    } else if (bulletType === BULLET_TYPES.UPGRADED) {
                        bulletType = BULLET_TYPES.SPREAD;
                        player.bulletSpread = 3; // 三发子弹
                        createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '散射子弹');
                    } else if (bulletType === BULLET_TYPES.SPREAD) {
                        bulletType = BULLET_TYPES.SPECIAL;
                        createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '超级子弹');
                    }
                    break;
                case 'SPECIAL_CHARGE':
                    specialCharge = Math.min(specialMaxCharge, specialCharge + 30);
                    createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, '能量+30');
                    break;
            }
            powerups.splice(index, 1);
            updateGameInfo();
        }
        
        // 创建道具效果动画
        function createPowerupEffect(x, y, text) {
            const effect = {
                x, y,
                text,
                opacity: 1,
                size: 16,
                speed: 1
            };
            explosions.push(effect);
        }
        
        // 绘制爆炸效果
        function drawExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                if (explosion.particles) {
                    // 粒子爆炸效果
                    let allParticlesGone = true;
                    for (let j = explosion.particles.length - 1; j >= 0; j--) {
                        const particle = explosion.particles[j];
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.life -= 0.02;
                        
                        if (particle.life > 0) {
                            allParticlesGone = false;
                            ctx.fillStyle = `rgba(${particle.r}, ${particle.g}, ${particle.b}, ${particle.life})`;
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            explosion.particles.splice(j, 1);
                        }
                    }
                    if (allParticlesGone) explosions.splice(i, 1);
                } else if (explosion.text) {
                    // 文字效果
                    explosion.y -= explosion.speed;
                    explosion.opacity -= 0.02;
                    explosion.size += 0.2;
                    
                    if (explosion.opacity <= 0) {
                        explosions.splice(i, 1);
                    } else {
                        ctx.fillStyle = `rgba(255, 255, 255, ${explosion.opacity})`;
                        ctx.font = `bold ${explosion.size}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(explosion.text, explosion.x, explosion.y);
                    }
                } else {
                    // 圆形爆炸效果
                    explosion.radius += explosion.speed;
                    explosion.opacity -= 0.05;
                    
                    if (explosion.opacity <= 0) {
                        explosions.splice(i, 1);
                    } else {
                        // 爆炸外圈
                        ctx.strokeStyle = `rgba(255, 200, 100, ${explosion.opacity})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // 爆炸内圈
                        ctx.strokeStyle = `rgba(255, 50, 50, ${explosion.opacity * 0.7})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(explosion.x, explosion.y, explosion.radius * 0.7, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // 爆炸中心
                        ctx.fillStyle = `rgba(255, 255, 100, ${explosion.opacity * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(explosion.x, explosion.y, explosion.radius * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        // 创建爆炸效果
        function createExplosion(x, y, size, createParticles = false) {
            explosions.push({
                x, y,
                radius: 5,
                speed: size / 20,
                opacity: 1
            });
            
            if (createParticles) {
                const particles = [];
                for (let i = 0; i < size; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    const life = 1;
                    const size = Math.random() * 3 + 1;
                    const r = Math.floor(Math.random() * 100) + 155;
                    const g = Math.floor(Math.random() * 100);
                    const b = Math.floor(Math.random() * 100);
                    
                    particles.push({ x, y, vx, vy, life, size, r, g, b });
                }
                explosions.push({ particles });
            }
        }
        
        // 检测碰撞
        function checkCollisions() {
            // 子弹与敌人碰撞
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bulletType.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bulletType.height > enemy.y
                    ) {
                        // 敌人受伤
                        enemy.health -= bulletType.damage;
                        bullets.splice(i, 1);
                        
                        // 创建小型爆炸效果
                        createExplosion(
                            bullet.x + bulletType.width / 2, 
                            bullet.y + bulletType.height / 2, 
                            5 + bulletType.damage * 2
                        );
                        
                        // 敌人死亡
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 15 + enemy.type * 5, true);
                            score += enemy.points;
                            updateGameInfo();
                            
                            // 生成掉落道具
                            spawnDroppedPowerup(enemy.x + enemy.width / 2 - 15, enemy.y + enemy.height / 2 - 15);
                            
                            // 增加特殊技能能量
                            specialCharge = Math.min(specialMaxCharge, specialCharge + 5 + enemy.type * 2);
                            
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
            
            // 玩家与敌人碰撞
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (
                    player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y
                ) {
                    // 护盾先承受伤害
                    const damage = 20;
                    if (player.shield > 0) {
                        player.shield -= damage;
                        if (player.shield < 0) player.shield = 0;
                    } else {
                        player.health -= damage;
                    }
                    
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 15 + enemy.type * 5, true);
                    enemies.splice(i, 1);
                    updateGameInfo();
                    
                    if (player.health <= 0) {
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, 60, true);
                        endGame();
                    }
                }
            }
        }
        
        // 处理玩家输入
        function handleInput() {
            // 减速效果（如果速度提升时间结束）
            if (player.speedBoost > 0) {
                player.speedBoost--;
                if (player.speedBoost <= 0) {
                    player.speed = PLAYER_SPEED;
                }
            }
            
            // 平滑移动控制
            if (keys['ArrowLeft'] || keys['KeyA']) {
                moveVelocityX = Math.max(moveVelocityX - MOVE_ACCELERATION, -player.speed);
            } else if (keys['ArrowRight'] || keys['KeyD']) {
                moveVelocityX = Math.min(moveVelocityX + MOVE_ACCELERATION, player.speed);
            } else {
                // 自然减速
                moveVelocityX *= MOVE_FRICTION;
                if (Math.abs(moveVelocityX) < 0.1) moveVelocityX = 0;
            }
            
            if (keys['ArrowUp'] || keys['KeyW']) {
                moveVelocityY = Math.max(moveVelocityY - MOVE_ACCELERATION, -player.speed);
            } else if (keys['ArrowDown'] || keys['KeyS']) {
                moveVelocityY = Math.min(moveVelocityY + MOVE_ACCELERATION, player.speed);
            } else {
                // 自然减速
                moveVelocityY *= MOVE_FRICTION;
                if (Math.abs(moveVelocityY) < 0.1) moveVelocityY = 0;
            }
            
            // 应用移动速度
            player.x += moveVelocityX;
            player.y += moveVelocityY;
            
            // 边界检查
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > WIDTH) player.x = WIDTH - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > HEIGHT) player.y = HEIGHT - player.height;
            
            // 射击控制
            const now = Date.now();
            if ((keys['Space'] || keys['KeyJ']) && now - player.lastShot > player.shootDelay) {
                player.lastShot = now;
                
                // 根据子弹类型创建不同数量的子弹
                if (player.bulletSpread === 1) {
                    // 单发
                    bullets.push({
                        x: player.x + player.width / 2 - bulletType.width / 2,
                        y: player.y - bulletType.height
                    });
                } else if (player.bulletSpread === 3) {
                    // 三发散射
                    bullets.push({
                        x: player.x + player.width / 2 - bulletType.width / 2,
                        y: player.y - bulletType.height
                    });
                    bullets.push({
                        x: player.x + player.width / 2 - bulletType.width / 2 - 15,
                        y: player.y - bulletType.height,
                        angle: -0.2
                    });
                    bullets.push({
                        x: player.x + player.width / 2 - bulletType.width / 2 + 15,
                        y: player.y - bulletType.height,
                        angle: 0.2
                    });
                }
                
                // 射击特效
                createExplosion(
                    player.x + player.width / 2, 
                    player.y - 10, 
                    10, 
                    false
                );
            }
            
            // 特殊技能冷却显示
            if (specialCharge >= specialMaxCharge) {
                document.getElementById('special').classList.add('text-space-orange');
                document.getElementById('special').classList.add('glow');
            } else {
                document.getElementById('special').classList.remove('text-space-orange');
                document.getElementById('special').classList.remove('glow');
            }
        }
        
        // 游戏主循环
        function gameLoop(timestamp) {
            if (gameOver || gamePaused) return;
            
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // 绘制背景（星空、行星、星云）
            drawStars();
            
            // 生成敌人
            spawnEnemy(timestamp);
            
            // 生成随机道具
            spawnRandomPowerup(timestamp);
            
            // 处理玩家输入
            handleInput();
            
            // 绘制玩家
            drawPlayer();
            
            // 绘制子弹
            drawBullets();
            
            // 绘制敌人
            drawEnemies();
            
            // 绘制道具
            drawPowerups();
            
            // 检测碰撞
            checkCollisions();
            
            // 绘制爆炸效果
            drawExplosions();
            
            // 更新特殊技能能量
            if (specialCharge < specialMaxCharge) {
                specialCharge = Math.min(specialMaxCharge, specialCharge + 0.05);
                updateGameInfo();
            }
            
            // 继续游戏循环
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 初始化游戏
        window.onload = init;
    </script>
</body>
</html>